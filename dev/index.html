<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cozy Voxel Farm 3D â€” First-Person Vanilla JS</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#87ceeb;font-family:sans-serif}
  #ui{position:fixed;top:10px;left:10px;z-index:10;background:rgba(255,255,255,0.8);padding:10px;border-radius:10px;box-shadow:0 4px 10px rgba(0,0,0,0.2)}
  #ui span{display:inline-block;margin:0 5px}
  canvas{width:100%;height:100%;display:block;cursor:crosshair}
</style>
</head>
<body>
<div id="ui">
  <div><strong>Cozy Voxel Farm 3D</strong></div>
  <div>WASD - ruch | Mysz - rozglÄ…danie | LPM - uÅ¼yj | PPM - sadÅº/usuÅ„ | E - zmiana narzÄ™dzia</div>
  <div>ðŸŒ¾ <span id="seeds">0</span> ðŸ’§ <span id="water">0</span> ðŸ”‹ <span id="stamina">100</span></div>
</div>
<canvas id="game"></canvas>
<script>
// --- Setup ---
const canvas=document.getElementById('game');
const ctx=canvas.getContext('webgl2',{antialias:true});
canvas.width=innerWidth;canvas.height=innerHeight;
window.addEventListener('resize',()=>{canvas.width=innerWidth;canvas.height=innerHeight;gl.viewport(0,0,gl.canvas.width,gl.canvas.height)});

// For simplicity, we'll simulate a 3D voxel farm using basic WebGL cubes
const gl=ctx;
const vsSource=`#version 300 es
in vec4 aPos;in vec3 aColor;uniform mat4 uMVP;out vec3 vColor;void main(){gl_Position=uMVP*aPos;vColor=aColor;}`;
const fsSource=`#version 300 es
precision mediump float;in vec3 vColor;out vec4 frag;void main(){frag=vec4(vColor,1.0);}`;

function compileShader(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))console.error(gl.getShaderInfoLog(s));return s;}
const vs=compileShader(gl.VERTEX_SHADER,vsSource),fs=compileShader(gl.FRAGMENT_SHADER,fsSource);
const prog=gl.createProgram();gl.attachShader(prog,vs);gl.attachShader(prog,fs);gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS))console.error(gl.getProgramInfoLog(prog));gl.useProgram(prog);

// Cube geometry
const cubeVerts=new Float32Array([
// pos(x,y,z) color(r,g,b)
 -0.5,-0.5,-0.5, 0.3,0.2,0.1,  0.5,-0.5,-0.5, 0.3,0.2,0.1,  0.5,0.5,-0.5, 0.3,0.2,0.1,  -0.5,0.5,-0.5, 0.3,0.2,0.1, // back
 -0.5,-0.5,0.5, 0.3,0.7,0.3,  0.5,-0.5,0.5, 0.3,0.7,0.3,  0.5,0.5,0.5, 0.3,0.7,0.3,  -0.5,0.5,0.5, 0.3,0.7,0.3 // front
]);
const cubeIdx=new Uint16Array([0,1,2,0,2,3, 4,5,6,4,6,7]);
const vao=gl.createVertexArray();gl.bindVertexArray(vao);
const vbo=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vbo);gl.bufferData(gl.ARRAY_BUFFER,cubeVerts,gl.STATIC_DRAW);
const ebo=gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ebo);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,cubeIdx,gl.STATIC_DRAW);
const aPos=gl.getAttribLocation(prog,'aPos');const aColor=gl.getAttribLocation(prog,'aColor');
const stride=6*4;gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,stride,0);gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aColor,3,gl.FLOAT,false,stride,3*4);gl.enableVertexAttribArray(aColor);

// Uniforms and camera
const uMVP=gl.getUniformLocation(prog,'uMVP');
function mat4Mult(a,b){let r=new Float32Array(16);for(let i=0;i<4;i++)for(let j=0;j<4;j++){r[i*4+j]=0;for(let k=0;k<4;k++)r[i*4+j]+=a[i*4+k]*b[k*4+j];}return r;}
function perspective(fov,aspect,near,far){const f=1/Math.tan(fov/2);return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)/(near-far),-1, 0,0,(2*far*near)/(near-far),0]);}
function lookAt(eye,center,up){const f=normalize(sub(center,eye));const s=normalize(cross(f,up));const u=cross(s,f);const m=new Float32Array([s[0],u[0],-f[0],0, s[1],u[1],-f[1],0, s[2],u[2],-f[2],0, 0,0,0,1]);const t=new Float32Array([1,0,0,-eye[0], 0,1,0,-eye[1], 0,0,1,-eye[2], 0,0,0,1]);return mat4Mult(m,t);} 
function sub(a,b){return [a[0]-b[0],a[1]-b[1],a[2]-b[2]];}function cross(a,b){return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}function normalize(a){const l=Math.hypot(...a);return a.map(v=>v/l);} 

// World setup
const size=16;let world=[];for(let x=0;x<size;x++){world[x]=[];for(let y=0;y<size;y++){world[x][y]=0;if(Math.random()<0.3)world[x][y]=1;}}

// Player
let player={x:8,y:2,z:8,rotY:0,rotX:0,seeds:5,water:5,stamina:100,tool:'seeds'};

// Input
let keys={};window.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
let mouseLocked=false;canvas.addEventListener('click',()=>{canvas.requestPointerLock();});document.addEventListener('pointerlockchange',()=>{mouseLocked=document.pointerLockElement===canvas;});
let dX=0,dY=0;document.addEventListener('mousemove',e=>{if(mouseLocked){player.rotY-=e.movementX*0.002;player.rotX-=e.movementY*0.002;player.rotX=Math.max(-1.5,Math.min(1.5,player.rotX));}});

// Main loop
function update(dt){const speed=5*dt;let dir=[0,0,0];if(keys['w'])dir[2]-=1;if(keys['s'])dir[2]+=1;if(keys['a'])dir[0]-=1;if(keys['d'])dir[0]+=1;const sinY=Math.sin(player.rotY),cosY=Math.cos(player.rotY);player.x+= (dir[0]*cosY - dir[2]*sinY)*speed;player.z+= (dir[0]*sinY + dir[2]*cosY)*speed;}
function render(){gl.clearColor(0.53,0.81,0.98,1);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);gl.enable(gl.DEPTH_TEST);
  const aspect=canvas.width/canvas.height;const proj=perspective(Math.PI/3,aspect,0.1,100);
  const eye=[player.x,player.y,player.z];const dir=[Math.sin(player.rotY)*Math.cos(player.rotX),Math.sin(player.rotX),Math.cos(player.rotY)*Math.cos(player.rotX)];const center=[eye[0]+dir[0],eye[1]+dir[1],eye[2]+dir[2]];const view=lookAt(eye,center,[0,1,0]);
  for(let x=0;x<size;x++)for(let z=0;z<size;z++){if(world[x][z]===1){const model=new Float32Array([1,0,0,x-size/2,0,1,0,0,0,0,1,z-size/2,0,0,0,1]);const mvp=mat4Mult(proj,mat4Mult(view,model));gl.uniformMatrix4fv(uMVP,false,mvp);gl.bindVertexArray(vao);gl.drawElements(gl.TRIANGLES,12,gl.UNSIGNED_SHORT,0);}}
}
let last=0;function loop(t){const dt=(t-last)/1000;last=t;update(dt);render();requestAnimationFrame(loop);}requestAnimationFrame(loop);
</script>
</body>
</html>

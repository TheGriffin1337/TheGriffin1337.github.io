<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cozy Voxel Farm â€” single-file vanilla JS</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
  #ui{position:fixed;left:12px;top:12px;z-index:20;background:rgba(255,255,255,0.9);backdrop-filter:blur(4px);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.12);}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(#87ceeb,#97c1ff);cursor:crosshair}
  .row{display:flex;gap:8px;align-items:center}
  .slot{width:40px;height:40px;border-radius:8px;border:2px solid #333;background:#fff;display:flex;align-items:center;justify-content:center;font-weight:700}
  button{padding:6px 10px;border-radius:8px;border:1px solid #888;background:#f7f7f7}
  #log{max-width:320px;max-height:220px;overflow:auto;margin-top:8px;font-size:13px}
  #help{font-size:13px;color:#333}
</style>
</head>
<body>
<div id="ui">
  <div class="row">
    <div><strong>Cozy Voxel Farm</strong></div>
    <div style="margin-left:8px;color:#666;font-size:13px">(vanilla JS, single file)</div>
  </div>
  <div style="height:8px"></div>
  <div class="row">
    <div class="slot" id="slot-tool">ðŸŒ¾</div>
    <div style="display:flex;flex-direction:column">
      <div id="tool-name">Siewnik</div>
      <div id="stamina" style="font-size:12px;color:#666">Stamina: <span id="stam-val">100</span>%</div>
    </div>
  </div>
  <div style="height:8px"></div>
  <div id="help">
    Sterowanie: WASD - ruch | Mysz - celowanie | LMB - uÅ¼yj/wyoruj/zbierz | RMB - sadÅº/usuÅ„ | E - pasek
  </div>
  <div id="log"></div>
</div>
<canvas id="c"></canvas>
<script>
/*
  Cozy Voxel Farm
  - single-file vanilla JS "voxel" renderer (isometric cubes)
  - grid world, simple camera & player, placing/removing, tilling, planting, watering, crop growth
  - intentionally compact and readable â€” extend as you wish
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W=innerWidth, H=innerHeight; function resize(){W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H}resize();addEventListener('resize',resize);

// --- world definition ---
const MAP_SIZE = 28;
const MAX_H = 6;
let world = []; // 3d array [x][y][z]
for(let x=0;x<MAP_SIZE;x++){world[x]=[];for(let y=0;y<MAP_SIZE;y++){world[x][y]=[];for(let z=0;z<MAX_H;z++){world[x][y][z]=0}}}
// block types
const B_EMPTY=0, B_GRASS=1, B_DIRT=2, B_TILLED=3, B_WATER=4, B_CROP_BASE=10; // crop stages are 10..14

// initial terrain: grass with a small pond and a prepared farm patch
for(let x=0;x<MAP_SIZE;x++)for(let y=0;y<MAP_SIZE;y++){let h=1; world[x][y][0]=B_GRASS}
// small pond
for(let x=10;x<14;x++)for(let y=3;y<10;y++){world[x][y][0]=B_WATER}
// tilled farm patch
for(let x=4;x<12;x++)for(let y=8;y<16;y++){world[x][y][0]=B_TILLED}

// crop data: map of {x,y} -> {stage,watered,ticks}
let crops = {};
function cropKey(x,y){return x+','+y}

// player
let player = {x:8,y:20,z:1,dir:0}; // dir 0..3
let cam={x:player.x,y:player.y,zoom:40,angle:45};

// UI
const slotTool = document.getElementById('slot-tool');
const toolName = document.getElementById('tool-name');
const stamVal = document.getElementById('stam-val');
const logEl = document.getElementById('log');
let inventory = {seeds:20,water:10};
let selectedTool='seeds';
function log(s){const d=document.createElement('div');d.textContent=s;logEl.prepend(d)}

// input
let keys = {};
addEventListener('keydown',e=>{keys[e.key.toLowerCase()]=true; if(e.key==='e'||e.key==='E'){toggleInventory()}})
addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false})
let mouse={x:0,y:0,down:false,right:false};
canvas.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect();mouse.x=e.clientX-r.left;mouse.y=e.clientY-r.top})
canvas.addEventListener('mousedown',e=>{mouse.down = true; if(e.button===2) mouse.right=true})
canvas.addEventListener('mouseup',e=>{mouse.down=false; if(e.button===2) mouse.right=false})
canvas.addEventListener('contextmenu',e=>e.preventDefault());

// inventory toggle
let invOpen=false; function toggleInventory(){invOpen=!invOpen; if(invOpen){slotTool.textContent = 'ðŸ¥•'+inventory.seeds}else{slotTool.textContent = selectedTool==='seeds'?'ðŸŒ¾':'ðŸ’§'}}

// projection: isometric-ish from grid coords (x,y,z) to screen
function project(x,y,z){
  const isoX = (x-y) * cam.zoom/2;
  const isoY = (x+y) * cam.zoom/4 - z * cam.zoom/2;
  return {sx: Math.floor(W/2 + isoX - (player.x-player.y)*cam.zoom/2), sy: Math.floor(H/2 + isoY - (player.x+player.y)*cam.zoom/4)};
}

// cube drawing
function drawCube(x,y,z,type){
  const p = project(x,y,z);
  const top = {x:p.sx, y:p.sy - cam.zoom/2};
  const left = {x:p.sx - cam.zoom/2, y:p.sy};
  const right = {x:p.sx + cam.zoom/2, y:p.sy};
  // colors
  let base='#888';
  if(type===B_GRASS) base='#6aa84f';
  if(type===B_DIRT) base='#9a6b3d';
  if(type===B_TILLED) base='#7b4f3b';
  if(type===B_WATER) base='#3aa0f3';
  if(type>=B_CROP_BASE) base='#5c9e3c';
  // shade faces
  ctx.beginPath(); ctx.moveTo(top.x,top.y); ctx.lineTo(right.x,right.y); ctx.lineTo(right.x,right.y+cam.zoom/2); ctx.lineTo(top.x,top.y+cam.zoom/2); ctx.closePath(); ctx.fillStyle=shade(base,0.07); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(top.x,top.y); ctx.lineTo(left.x,left.y); ctx.lineTo(left.x,left.y+cam.zoom/2); ctx.lineTo(top.x,top.y+cam.zoom/2); ctx.closePath(); ctx.fillStyle=shade(base,-0.1); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(top.x,top.y); ctx.lineTo(right.x,right.y); ctx.lineTo(left.x,left.y); ctx.closePath(); ctx.fillStyle=shade(base,0.15); ctx.fill(); ctx.stroke();
}
function shade(hex,amt){ // amt -0.5..0.5
  const c = hexToRgb(hex); if(!c) return hex; let {r,g,b}=c; r=Math.min(255,Math.max(0,Math.round(r*(1+amt)))); g=Math.min(255,Math.max(0,Math.round(g*(1+amt)))); b=Math.min(255,Math.max(0,Math.round(b*(1+amt)))); return `rgb(${r},${g},${b})` }
function hexToRgb(h){ if(!h) return null; if(h[0]==='#')h=h.slice(1); if(h.length===3) h = h.split('').map(ch=>ch+ch).join(''); const bigint=parseInt(h,16); return {r:(bigint>>16)&255,g:(bigint>>8)&255,b:bigint&255}; }

// simple render loop
function render(){
  ctx.clearRect(0,0,W,H);
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#87ceeb'); g.addColorStop(1,'#bfe1ff'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.lineWidth=1;
  // camera follows player smoothly
  player.x += (cam.x - player.x)*0.02; player.y += (cam.y - player.y)*0.02;
  // build list of visible cubes
  let cubes = [];
  for(let x=0;x<MAP_SIZE;x++)for(let y=0;y<MAP_SIZE;y++)for(let z=0;z<MAX_H;z++){let t = world[x][y][z]; if(t!==B_EMPTY) cubes.push({x,y,z,t})}
  // crops overlay
  for(const k in crops){const [x,y]=k.split(',').map(Number);const data=crops[k]; let t = B_CROP_BASE + Math.min(4,data.stage); cubes.push({x,y,z:1,t})}
  // sort by depth
  cubes.sort((a,b)=> (a.x+a.y+a.z) - (b.x+b.y+b.z) );
  for(const c of cubes) drawCube(c.x,c.y,c.z,c.t);
  // player marker
  const pp = project(player.x,player.y,player.z);
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.beginPath(); ctx.arc(pp.sx,pp.sy-10,8,0,Math.PI*2); ctx.fill();
  // highlight hovered cell
  const hovered = screenToCell(mouse.x,mouse.y);
  if(hovered) {
    const {x,y,z}=hovered; const p = project(x,y,z);
    ctx.strokeStyle='rgba(255,255,255,0.95)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p.sx,p.sy-cam.zoom/2); ctx.lineTo(p.sx-cam.zoom/2,p.sy); ctx.lineTo(p.sx,p.sy+cam.zoom/2); ctx.lineTo(p.sx+cam.zoom/2,p.sy); ctx.closePath(); ctx.stroke();
  }
}

// convert screen pos to approximate grid cell (inverse of project)
function screenToCell(sx,sy){ // returns nearest x,y and z=top
  // naive: iterate cells, find which projected diamond contains point
  for(let x=0;x<MAP_SIZE;x++)for(let y=0;y<MAP_SIZE;y++){
    const p = project(x,y,1);
    const dx = sx - p.sx; const dy = sy - p.sy;
    if(Math.abs(dx) <= cam.zoom/2 && Math.abs(dy) <= cam.zoom/2 && Math.abs(Math.abs(dx)+Math.abs(dy))<=cam.zoom){
      return {x,y,z:1}
    }
  }
  return null;
}

// main update
let tick=0; setInterval(()=>{
  tick++;
  // update crops every 3 seconds or so
  if(tick%3===0){
    for(const k in crops){const c=crops[k]; if(c.watered){ c.ticks++; if(c.ticks>=3){c.ticks=0; c.stage++; if(c.stage>=4){ /* mature */ } } c.watered=false } }
  }
  // simple passive regen stamina
  if(player.stamina<100) player.stamina=Math.min(100, (player.stamina||100) + 2);
},1000);

function gameLoop(){
  // movement
  if(keys['w']) {player.y -= 0.06}
  if(keys['s']) {player.y += 0.06}
  if(keys['a']) {player.x -= 0.06}
  if(keys['d']) {player.x += 0.06}
  // camera center
  cam.x = Math.max(0, Math.min(MAP_SIZE-1, player.x)); cam.y = Math.max(0, Math.min(MAP_SIZE-1, player.y));
  // interactions on click
  if(mouse.down){handleUse(mouse.right)}
  render(); requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

// use/interaction
let lastUse=0; function handleUse(isRight){ if(performance.now()-lastUse<200) return; lastUse=performance.now(); const cell=screenToCell(mouse.x,mouse.y); if(!cell) return; const x=cell.x,y=cell.y;
  if(isRight){ // plant or remove
    if(world[x][y][0]===B_TILLED && inventory.seeds>0){ // plant seed
      const k=cropKey(x,y); if(!crops[k]){crops[k]={stage:0,watered:false,ticks:0}; inventory.seeds--; log('Posadzono nasionko.'); slotTool.textContent='ðŸŒ¾'} else { log('Tu juÅ¼ roÅ›nie coÅ›.'); }
    } else { // remove crop
      const k=cropKey(x,y); if(crops[k]){delete crops[k]; log('UsuniÄ™to roÅ›linkÄ™.'); }
    }
  } else { // left click: till/water/harvest
    const t = world[x][y][0];
    if(t===B_GRASS){ world[x][y][0]=B_DIRT; log('Przekopano trawÄ™ na ziemiÄ™.'); player.stamina=(player.stamina||100)-5 }
    else if(t===B_DIRT){ world[x][y][0]=B_TILLED; log('ZoraÅ‚eÅ› ziemiÄ™.'); player.stamina=(player.stamina||100)-5 }
    else if(t===B_WATER){ // pickup water
      inventory.water++; log('NabraÅ‚eÅ› wody.'); slotTool.textContent='ðŸ’§'}
    // water crops if you have water
    const k=cropKey(x,y); if(crops[k] && inventory.water>0){crops[k].watered=true; inventory.water--; log('PodlaÅ‚eÅ› roÅ›linÄ™.');}
    // harvest if matured
    if(crops[k] && crops[k].stage>=4){ delete crops[k]; inventory.seeds += 2; log('Zebrano plony â€” +2 nasionka.'); }
  }
  updateUI();
}

function updateUI(){ slotTool.textContent = selectedTool==='seeds' ? 'ðŸŒ¾'+inventory.seeds : 'ðŸ’§'+inventory.water; stamVal.textContent = Math.round(player.stamina||100); }
updateUI();

// small tutorial messages
log('Witaj na farmie! UÅ¼yj LPM (klik) by dziaÅ‚aÄ‡. PPM by sadziÄ‡/usuwaÄ‡.');
log('OdwiedÅº zagon â€” zoraÄ‡ (klik), posadziÄ‡ (PPM), podlaÄ‡ (klik po wodzie).');

// Expose a quick save/load via localStorage
window.addEventListener('keydown',e=>{if(e.key==='p'){localStorage.setItem('farm_world',JSON.stringify({world,crops,inventory,player})); log('Zapisano farmÄ™.')} if(e.key==='l'){const s=localStorage.getItem('farm_world'); if(s){const d=JSON.parse(s);world=d.world; crops=d.crops; inventory=d.inventory; player=d.player; log('Wczytano farmÄ™.'); updateUI();}}})

// simple camera zoom with mouse wheel
addEventListener('wheel',e=>{cam.zoom = Math.max(18, Math.min(80, cam.zoom - e.deltaY*0.01))})

// neat: simple day/night ambient overlay cycle
let dayT=0; setInterval(()=>{ dayT = (dayT+1) % 240; const night = Math.max(0, Math.sin(dayT/240*Math.PI*2)); canvas.style.filter = `brightness(${1 - night*0.35})` },1000);

</script>
</body>
</html>
